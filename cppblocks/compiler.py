'''
A compiler for disabled CPP conditional blocks.

The compiler walks the AST generated by CppParser using the tree visitor from
the Spark framework.
'''

from expr import evalCondExpression

class DisabledBlocksCompiler:
    def __init__(self, filepath, analyzeHeaders, database, fileFinderAngleInclude, fileFinderQuoteInclude, astRootNode):
        self.filepath = filepath
        self.analyzeHeaders = analyzeHeaders
        self.symbols = database
        self.fileFinderAngleInclude = fileFinderAngleInclude
        self.fileFinderQuoteInclude = fileFinderQuoteInclude
        self.rootNode = astRootNode
        self.disabledBlocks = { self.filepath : [] }

        self.visitorMap = {
                'ifSection' : self.v_ifSection,
                'ifdef' : self.v_ifdef,
                'ifndef' : self.v_ifndef,
                'if' : self.v_if,
                'elif' : self.v_elif,
                'define' : self.v_define,
                'undef' : self.v_undef,
                'includeAngle' : self.v_includeAngle,
                'includeQuote' : self.v_includeQuote
        }

    def getDisabledBlocks(self):
        if self.rootNode:
            self.traversePreorder(self.rootNode)
        return self.disabledBlocks

    def traversePreorder(self, node):
        children = []

        visitChildren = self.visit(node)

        if type(visitChildren) is list:
            children = visitChildren # Visitor returned a list of children to process
        elif visitChildren: # Visitor wants to visit its children
            children = node.children

        for child in children:
            self.traversePreorder(child)

        for sibling in node.siblings:
            self.traversePreorder(sibling)

    def visit(self, node):
        if not node.typ in self.visitorMap:
            raise UnsupportedToken(node)
        visitor = self.visitorMap[node.typ]
        return visitor(node)

    def v_ifdef(self, node):
        return self.symbols.defined(node.symbol)

    def v_ifndef(self, node):
        return not self.symbols.defined(node.symbol)

    def v_if(self, node):
        return evalCondExpression(self.symbols, node.expression)

    def v_elif(self, node):
        return evalCondExpression(self.symbols, node.expression)

    def v_ifSection(self, node):
        ifExprResult = self.visit(node.ifGroup)
        if ifExprResult:
            self.disableElifAndElseGroups(node.elifGroups, node.elseGroup)
            return node.ifGroup.children
        else:
            return self.doIfCondFalse(node)

    def disableElifAndElseGroups(self, elifGroups, elseGroup):
        if elifGroups:
            for node in elifGroups:
                self.addDisabledBlock(node.line, node.length)
        if elseGroup:
            self.addDisabledBlock(elseGroup.line, elseGroup.length)

    def doIfCondFalse(self, node):
        # Mark the if block as disabled
        self.addDisabledBlock(node.ifGroup.line, node.ifGroup.length)
        # Process all elif blocks, the function returns a list of child nodes
        # if one condition evaluated to true and else it returns False.
        children = self.processElifGroups(node.elifGroups)
        if type(children) is list:
            # Elif block evaluated to true, mark else block as inactive
            if node.elseGroup:
                self.addDisabledBlock(node.elseGroup.line, node.elseGroup.length)
            return children
        else:
            # All elif blocks evaluated to false, we enter the else-block if we have one.
            # If there is no else block, we return False and indicate that the
            # tree traversal should continue with the next CPP directive on the
            # same indentation level Never visit any children of v_ifSection
            # unless we explicitly return a list of children
            if node.elseGroup:
                return node.elseGroup.children
            else:
                return False

    def processElifGroups(self, elifGroups):
        ''' Process all elif conditions.

        Adds all inactive elif blocks to the disabled blocks list.

        Returns a children list if one elif group evaluated to true and False
        if all elif conditions evaluated to False.
        '''
        idx = 0
        for elifNode in elifGroups:
            elifExprResult = evalCondExpression(self.symbols, elifNode.expression)
            # If this elif's expression evaluates to true, we disable all the
            # elif blocks preceeding it and all the elif block following it.
            # We exploit Python's very convenient array slicing semantics to
            # avoid tricky special case handling here.
            if elifExprResult:
                self.disableElifGroups(elifGroups[0:idx])
                self.disableElifGroups(elifGroups[idx+1:-1])
                return elifNode.children # No point to continue the evaluation of elif conditions
        # If we reach this statement, all elif conditions evaluated to false
        self.disableElifGroups(elifGroups)
        return False

    def disableElifGroups(self, elifGroups):
        for elifGroup in elifGroups:
            self.addDisabledBlock(elifGroup.line, elifGroup.length)

    def v_define(self, node):
        self.symbols.add(node.name, node.value)

    def v_undef(self, node):
        self.symbols.remove(node.symbol)

    def v_includeAngle(self, node):
        includePath = self.fileFinderAngleInclude.lookup(node.path)
        self.v_include(includePath)

    def v_includeQuote(self, node):
        includePath = self.fileFinderQuoteInclude.lookup(self.filepath, node.path)
        self.v_include(includePath)

    def v_include(self, includePath):
        # Be careful with this cyclic import. See http://stackoverflow.com/questions/11698530/two-python-modules-require-each-others-contents-can-that-work
        from analyzer import analyzeFile
        disabledBlocks = analyzeFile(includePath, self.analyzeHeaders, self.fileFinderAngleInclude, self.fileFinderQuoteInclude, self.symbols)

        if self.analyzeHeaders:
            self.disabledBlocks.update(disabledBlocks)

    def addDisabledBlock(self, start, length):
        ' By convention the first entry in disabledBlocks is always for the file we were invoked on. '
        self.disabledBlocks[self.filepath].append( (start,length) )

